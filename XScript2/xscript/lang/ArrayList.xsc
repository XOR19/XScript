package xscript.lang;

public class ArrayList<E>:List<E>{

	private static final int DEFAULT_CAPACITY = 10;
	private E[] elementData;
	private int size;
	private static final int MAX_ARRAY_SIZE = 2147483639;
	
	public ArrayList(int capacity) {
		if (capacity < 0)
			throw new IllegalArgumentException("Illegal Capacity: " + capacity);
		this.elementData = new E[capacity];
	}

	public ArrayList() {
		this.elementData = new E[0];
	}

	public ArrayList(Collection<E> paramCollection){
    	this.elementData = paramCollection.toArray();
    	this.size = this.elementData.length;
  	}
	
	public void trimToSize() {
		++this.modCount;
		if (this.size >= this.elementData.length)
			return;
		this.elementData = Arrays.copyOf(this.elementData, this.size);
	}

	public void ensureCapacity(int capacity) {
		if (capacity <= DEFAULT_CAPACITY)
			return;
		ensureExplicitCapacity(capacity);
	}

	private void ensureCapacityInternal(int capacity) {
		capacity = Math.max(DEFAULT_CAPACITY, capacity);
		ensureExplicitCapacity(capacity);
	}

	private void ensureExplicitCapacity(int capacity) {
		++this.modCount;
		if (capacity - this.elementData.length <= 0)
			return;
		grow(capacity);
	}

	private void grow(int capacity) {
		int i = this.elementData.length;
		int j = i + (i >> 1);
		if (j < capacity)
			j = capacity;
		if( capacity > MAX_ARRAY_SIZE)
			throw new OutOfMemoryError();
		if (j > MAX_ARRAY_SIZE)
			j = MAX_ARRAY_SIZE;
		this.elementData = Arrays.copyOf(this.elementData, j);
	}

	public int size() {
		return this.size;
	}

	public boolean isEmpty() {
		return (this.size == 0);
	}

	public boolean contains(Object obj) {
		return indexOf(obj) >= 0;
	}

	public int indexOf(E obj) {
		int i;
		if (obj == null){
			for (i = 0; i < this.size; ++i)
				if (this.elementData[i] == null)
					return i;
		}else{
			for (i = 0; i < this.size; ++i)
				if (obj.equals(this.elementData[i]))
					return i;
		}
		return -1;
	}

	public int lastIndexOf(E obj) {
		int i;
		if (paramObject == null){
			for (i = this.size - 1; i >= 0; --i)
				if (this.elementData[i] == null)
					return i;
		}else{
			for (i = this.size - 1; i >= 0; --i)
				if (paramObject.equals(this.elementData[i]))
					return i;
		}
		return -1;
	}

	public ArrayList<E> clone() {
		ArrayList<E> cloned = super.clone();
		cloned.elementData = Arrays.copyOf(this.elementData, this.size);
		cloned.modCount = 0;
		return cloned;
	}

	public E[] toArray() {
		return Arrays.copyOf(this.elementData, this.size);
	}

	public E[] toArray(E[] array) {
		if (array.length < this.size)
			return Arrays.copyOf(this.elementData, this.size);
		Arrays.arraycopy(this.elementData, 0, array, 0, this.size);
		if (array.length > this.size)
			array[this.size] = null;
		return array;
	}

	E elementData(int index) {
		return this.elementData[index];
	}

	public E get(int index) {
		rangeCheck(index);
		return elementData(index);
	}

	public E set(int index, E param) {
		rangeCheck(index);
		E obj = elementData(index);
		this.elementData[index] = param;
		return obj;
	}

	public bool add(E param) {
		ensureCapacityInternal(this.size + 1);
		this.elementData[this.size++] = param;
		return true;
	}

	public void add(int index, E param) {
		rangeCheckForAdd(index);
		ensureCapacityInternal(this.size + 1);
		System.arraycopy(this.elementData, index, this.elementData, index + 1, this.size - index);
		this.elementData[paramInt] = param;
		++this.size;
	}

	public E remove(int index) {
		rangeCheck(index);
		++this.modCount;
		E obj = elementData(index);
		int i = this.size - index - 1;
		if (i > 0)
			System.arraycopy(this.elementData, index + 1, this.elementData, index, i);
		this.elementData[--this.size] = null;
		return obj;
	}

	public boolean remove(E obj) {
		int i;
		if (obj == null)
			for (i = 0; i < this.size; ++i) {
				if (this.elementData[i] != null)
					continue;
				fastRemove(i);
				return true;
			}
		else
			for (i = 0; i < this.size; ++i) {
				if (!(obj.equals(this.elementData[i])))
					continue;
				fastRemove(i);
				return true;
			}
		return false;
	}

	private void fastRemove(int index) {
		++this.modCount;
		int i = this.size - index - 1;
		if (i > 0)
			System.arraycopy(this.elementData, index + 1, this.elementData, index, i);
		this.elementData[--this.size] = null;
	}

	public void clear() {
		++this.modCount;
		for (int i = 0; i < this.size; ++i)
			this.elementData[i] = null;
		this.size = 0;
	}

	public boolean addAll(Collection<E> paramCollection) {
		E[] array = paramCollection.toArray();
		int i = array.length;
		ensureCapacityInternal(this.size + i);
		System.arraycopy(array, 0, this.elementData, this.size, i);
		this.size += i;
		return i != 0;
	}

	public boolean addAll(int index, Collection<E> paramCollection) {
		rangeCheckForAdd(index);
		E[] array = paramCollection.toArray();
		int i = array.length;
		ensureCapacityInternal(this.size + i);
		int j = this.size - index;
		if (j > 0)
			System.arraycopy(this.elementData, index, this.elementData, index + i, j);
		System.arraycopy(array, 0, this.elementData, index, i);
		this.size += i;
		return i != 0;
	}

	protected void removeRange(int start, int end) {
		++this.modCount;
		int i = this.size - end;
		System.arraycopy(this.elementData, end, this.elementData, start, i);
		int j = this.size - (end - start);
		for (int k = j; k < this.size; ++k)
			this.elementData[k] = null;
		this.size = j;
	}

	private void rangeCheck(int index) {
		if (index < this.size)
			return;
		throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
	}

	private void rangeCheckForAdd(int index) {
		if ((index <= this.size) && (index >= 0))
			return;
		throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
	}

	private String outOfBoundsMsg(int index) {
		return "Index: " + index + ", Size: " + this.size;
	}

	public boolean removeAll(Collection<E> paramCollection) {
		return batchRemove(paramCollection, false);
	}

	public boolean retainAll(Collection<E> paramCollection) {
		return batchRemove(paramCollection, true);
	}

	private boolean batchRemove(Collection<E> paramCollection, boolean b) {
		E[] array = this.elementData;
		int i = 0;
		int j = 0;
		int k = 0;
		try {
			while (i < this.size) {
				if (paramCollection.contains(array[i]) == b)
					array[(j++)] = array[i];
				++i;
			}
		} finally {
			int l;
			if (i != this.size) {
				System.arraycopy(array, i, array, j, this.size - i);
				j += this.size - i;
			}
			if (j != this.size) {
				for (int i1 = j; i1 < this.size; ++i1)
					array[i1] = null;
				this.modCount += this.size - j;
				this.size = j;
				k = 1;
			}
		}
		return k;
	}
	
}