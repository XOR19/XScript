package xscript.lang;

public final class Arrays{

	public static native void arraycopy(Object src, int srcPos, Object dst, int dstPos, int length);
	
	public static native void sort(Object array);

	public static native void sort(Object array, int start, int end);

	private static void rangeCheck(int size, int start, int end) {
		if (start > end)
			throw new IllegalArgumentException("fromIndex(" + start
					+ ") > toIndex(" + end + ")");
		if (start < 0)
			throw new ArrayIndexOutOfBoundsException(start);
		if (end <= size)
			return;
		throw new ArrayIndexOutOfBoundsException(end);
	}

	public static native int binarySearch(Object array, Object value);

	public static native int binarySearch(Object array, int start, int end, Object value);

	public static <T> int binarySearch(T[] array, T value) {
		return binarySearch0(array, 0, array.length, value);
	}

	public static <T> int binarySearch(T[] array, int start, int end, T value) {
		rangeCheck(array.length, start, end);
		return binarySearch0(array, start, end, value);
	}

	private static <T> int binarySearch0(T[] array, int start, int end, T value) {
		int i = start;
		int j = end - 1;
		while (i <= j) {
			int k = i + j >>> 1;
			Comparable comperator = (Comparable) array[k];
			int l = comperator.compareTo(value);
			if (l < 0)
				i = k + 1;
			else if (l > 0)
				j = k - 1;
			else
				return k;
		}
		return -(i + 1);
	}

	public static <T> int binarySearch(T[] array, T value, Comparator<T> comparator) {
		return binarySearch0(array, 0, array.length, value, comparator);
	}

	public static <T> int binarySearch(T[] array, int start, int end, T value, Comparator<T> comparator) {
		rangeCheck(array.length, start, end);
		return binarySearch0(array, start, end, value, comparator);
	}

	private static <T> int binarySearch0(T[] array, int start, int end, T value, Comparator<T> comparator){
	    if (comparator == null)
	      	return binarySearch0(array, start, end, value);
	    int i = start;
	    int j = end - 1;
	    while (i <= j){
			int k = i + j >>> 1;
			T obj = array[k];
			int l = comparator.compare(obj, value);
			if (l < 0)
				i = k + 1;
			else if (l > 0)
				j = k - 1;
			else
				return k;
	    }
	    return -(i + 1);
  	}

	public static native boolean equals(Object array1, Object array2);

	public static <T> boolean equals(T[] array1, T[] array2) {
		if (array1 == array2)
			return true;
		if ((array1 == null) || (array2 == null))
			return false;
		int i = array1.length;
		if (array2.length != i)
			return false;
		for (int j = 0; j < i; ++j) {
			T obj1 = array1[j];
			T obj2 = array2[j];
			if (obj1 == null){
				if (obj2 != null)
					return false;
			}else if (!(obj1.equals(obj2)))
				return false;
		}
		return true;
	}

	public static native void fill(Object array, Object value);

	public static native Object copyOf(Object array, int size);

	public static native <T> T[] copyOf(T[] array, int size);

	public static native <T, U> T[] changeType(U[] array, int size);

	public static native <T, U> T[] changeType(U[] array, int size, int end);

	public static native Object copyOfRange(Object array, int start, int end);

	public static native <T> T[] copyOfRange(T[] array, int start, int end);

	public static int hashCode(Object array);

	public static int hashCode(Object[] array) {
		if (array == null)
			return 0;
		int i = 1;
		for (Object obj : array)
			i = 31 * i + ((obj == null) ? 0 : obj.hashCode());
		return i;
	}
			
}